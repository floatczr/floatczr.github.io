<!DOCTYPE html><html lang="ch" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>保护模式进阶 | floatc.rar</title><meta name="author" content="fLo4Tc"><meta name="copyright" content="fLo4Tc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="保护模式进阶获取内存在linux中有许多方法获取内存容量，其本质上是调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的 3 个子功能。  EAX&#x3D;0xE820：遍历主机上全部内存。 AX&#x3D;0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。 AH&#x3D;0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。  0xe8">
<meta property="og:type" content="article">
<meta property="og:title" content="保护模式进阶">
<meta property="og:url" content="http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="floatc.rar">
<meta property="og:description" content="保护模式进阶获取内存在linux中有许多方法获取内存容量，其本质上是调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的 3 个子功能。  EAX&#x3D;0xE820：遍历主机上全部内存。 AX&#x3D;0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。 AH&#x3D;0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。  0xe8">
<meta property="og:locale">
<meta property="og:image" content="https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png">
<meta property="article:published_time" content="2022-11-03T07:20:39.000Z">
<meta property="article:modified_time" content="2022-11-14T11:09:48.763Z">
<meta property="article:author" content="fLo4Tc">
<meta property="article:tag" content="操作系统真相还原">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '保护模式进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-14 19:09:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="floatc.rar" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/10/31/YCmjBOJQUDPzeLE.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">floatc.rar</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">保护模式进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-03T07:20:39.000Z" title="Created 2022-11-03 15:20:39">2022-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-14T11:09:48.763Z" title="Updated 2022-11-14 19:09:48">2022-11-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="保护模式进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="保护模式进阶"><a href="#保护模式进阶" class="headerlink" title="保护模式进阶"></a>保护模式进阶</h2><h3 id="获取内存"><a href="#获取内存" class="headerlink" title="获取内存"></a>获取内存</h3><p>在linux中有许多方法获取内存容量，其本质上是调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的 3 个子功能。</p>
<ul>
<li>EAX=0xE820：遍历主机上全部内存。</li>
<li>AX=0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。</li>
<li>AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。</li>
</ul>
<h4 id="0xe820子功能"><a href="#0xe820子功能" class="headerlink" title="0xe820子功能"></a>0xe820子功能</h4><h5 id="ARDS"><a href="#ARDS" class="headerlink" title="ARDS"></a>ARDS</h5><p>BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同，BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS）。</p>
<p><img src="https://s2.loli.net/2022/11/03/jIW1XrDbaRindM2.png" alt="image.png"></p>
<p>地址范围描述符大小是4个字节，共5个字段，一共20个字节，每次调用中断0x15时就会返回这样一个奇似描述符的数据结构。ADRS用高低共64位的地址来描述这段内存的基地址，又用高低各32位共64位的地址来描述这段内存的长度，最后用Type来标识这段内存的类型,这里所谓的类型是说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。</p>
<p><img src="https://s2.loli.net/2022/11/03/9PRcY8xD67tZJSb.png" alt="image.png"></p>
<p>由于在 32 位环境下工作，所以在 ARDS 结构属性中，我们只用到低 32 位属性。BaseAddrLow+LengthLow 是一片内存区域上限，单位是字节。</p>
<h5 id="调用0xe820"><a href="#调用0xe820" class="headerlink" title="调用0xe820"></a>调用0xe820</h5><p>此功能的调用步骤分为三步</p>
<ol>
<li><p>填写好“调用前输入”中列出的寄存器</p>
</li>
<li><p>执行中断调用 int 0x15</p>
</li>
<li><p>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/11/03/MGao7izyNXp4fJw.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/11/03/3bsH5VZtTjSRrNy.png" alt="image.png"></p>
<h4 id="0xe801子功能"><a href="#0xe801子功能" class="headerlink" title="0xe801子功能"></a>0xe801子功能</h4><p>0xe801子功能最多只能识别4GB内存，低于 15MB 的内存以 1KB 为单位大小来记录，单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的最大容量=AX * 1024 = 0x3c00 = 15MB。16MB～4GB 是以 64KB 为单位大小来记录的，单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的。</p>
<p><img src="https://s2.loli.net/2022/11/03/7VzIXU34jZn5Pvk.png" alt="image.png"></p>
<p>此中断的调用步骤如下：</p>
<ol>
<li><p>将 AX 寄存器写入 0xE801</p>
</li>
<li><p>执行中断调用 int 0x15</p>
</li>
<li><p>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</p>
</li>
</ol>
<h4 id="0x88子功能"><a href="#0x88子功能" class="headerlink" title="0x88子功能"></a>0x88子功能</h4><p>0x88子功能最多只能识别64MB的内存，当内存大于64MB是只会显示63MB，因为此功能只会显示1MB之上的内存，不包括这1MB，所以在使用之时要加上这1MB</p>
<p><img src="https://s2.loli.net/2022/11/03/sUfy6Rq9Hxo3Q1r.png" alt="image.png"></p>
<p>此中断的调用步骤如下：</p>
<ol>
<li>将 AX 寄存器写入 0x88</li>
<li>执行中断调用 int 0x15</li>
<li>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</li>
</ol>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="物理地址、虚拟地址、线性地址和逻辑地址"><a href="#物理地址、虚拟地址、线性地址和逻辑地址" class="headerlink" title="物理地址、虚拟地址、线性地址和逻辑地址"></a>物理地址、虚拟地址、线性地址和逻辑地址</h4><h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><p>物理地址就是物理上真正存在的地址，无论地址怎样变化，cpu最终访问的一定是物理地址。在实模式下，“段基址+偏移地址”直接输出的就是物理地址</p>
<h5 id="虚拟地址和线性地址"><a href="#虚拟地址和线性地址" class="headerlink" title="虚拟地址和线性地址"></a>虚拟地址和线性地址</h5><p>在保护模式下，“段基址+段内偏移地址”称为线性地址。选择子指向段描述符，描述符中有段的段基址，而段内偏移地址就是要访问地址的低位。若未开启分页，则该线性地址等同于物理地址。若开启了分页功能，就又称之为虚拟地址，虚拟地址要经过专门的CPU部件才会转化为真正的物理地址</p>
<h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><p>无论在实模式或是保护模式下，段内偏移地址又称为有效地址、也成为逻辑地址，也就是程序员可见的地址。</p>
<h5 id="地址之间的关系图"><a href="#地址之间的关系图" class="headerlink" title="地址之间的关系图"></a>地址之间的关系图</h5><p><img src="https://s2.loli.net/2022/11/05/X9moc7Z46IdylUH.png" alt="image.png"></p>
<h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>分页机制是建立在分段机制之上的。在保护模式中段寄存器中的内容是选择子，但选择子最终就是为了要找到段基址，其内存访问的核心机制依然是“段基址：段内偏移地址”，这两个地址在相加之后才是绝对地址，在未开启分页时，此地址直接等同于物理地址。</p>
<p><img src="https://s2.loli.net/2022/11/06/azBv9cP8HyqM6tK.png" alt="image.png"></p>
<p>开启分页之后，段部件输出的地址不再等同于物理地址，称之为虚拟地址，它是逻辑上的，是假的。</p>
<p><img src="https://s2.loli.net/2022/11/06/UcQ9G6s1Shgp7yJ.png" alt="image.png"></p>
<p>分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续，分页机制的作用有两方面：</p>
<ul>
<li><p>将线性地址转换成物理地址</p>
</li>
<li><p>用大小相等的页代替大小不等的段</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/11/06/bKIiCvfwAGajp8Z.png" alt="image.png"></p>
<p>每加载一个进程，操作系统按照进程中各段的起始范围，在进程自己的 4GB 虚拟地址空间中寻找可用空间分配内存段，此虚拟地址空间可以是页表，也可以是操作系统维护的某种数据结构，此阶段的分配是逻辑上的，并没有真正写入物理内存。在分页机制下，代码段和数据段在逻辑上被拆分为以页为单位的小内存块。接着操作系统开始为这些虚拟内存分配真正的物理页地址，并在页表中登记这些物理页地址，完成虚拟页到物理页的映射</p>
<h5 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h5><p>假设表中有4G个页表项，则32位的地址要用4字节的页表项来存储，页表总共大小位4Byte * 4G = 16GB，这种存储方法实际上就是将4G个页分配成4G个内存块，每个内存块为1字节大小，光页表就有16GB，得不偿失。所以解决方法就是少分几个页，将每个页的尺寸变大，CPU中采用的页就是4KB，所以4GB空间一共有4 * 1024 * 1024=1048576个页表项，也就是说页表中也需要1048576个页表项，这个页表被称为一级页表</p>
<p><img src="https://s2.loli.net/2022/11/06/2Ojh4Bn8tEIXlvG.png" alt="页表和物理地址"></p>
<p>由于页大小是4KB，所以页表项中的物理地址都是 4k 的整数倍，故用十六进制表示的地址，低 3 位都是 0。就拿第3 个页表项来说，其值为 0x3000，表示该页对应的物理地址是 0x3000。</p>
<h6 id="一级页表存在的问题"><a href="#一级页表存在的问题" class="headerlink" title="一级页表存在的问题"></a>一级页表存在的问题</h6><ol>
<li>一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB，用户进程要占用低 3GB</li>
<li>一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话，便是 4MB 大小，但是每个进程都有自己的页表，进程一多，光是页表占用的空间就相当大了</li>
</ol>
<h5 id="虚拟地址（线性地址）和物理地址的转换"><a href="#虚拟地址（线性地址）和物理地址的转换" class="headerlink" title="虚拟地址（线性地址）和物理地址的转换"></a>虚拟地址（线性地址）和物理地址的转换</h5><p>分页机制打开前要将页表地址加载到控制寄存器 cr3 中，这是启用分页机制的先决条件之一。所以，在打开分页机制前加载到寄存器 cr3 中的是页表的物理地址，页表中页表项的地址自然也是物理地址了。</p>
<p>一个页表项对应一个页，所以，用线性地址的高 20 位作为页表项的索引，每个页表项要占用 4 字节大小，所以这高 20 位的索引乘以 4 后才是该页表项相对于页表物理地址的字节偏移量。用 cr3 寄存器中的页表物理地址加上此偏移量便是该页表项的物理地址，从该页表项中得到映射的物理页地址，然后用线性地址的低 12 位与该物理页地址相加，所得的地址之和便是最终要访问的物理地址。</p>
<p>总结下就是：<em><em>页表项的物理地址 = CR3中页表的物理地址（物理起始地址） + 高20位虚拟地址 （页索引）</em> 4 （每个页表项大小）+ 低12位虚拟地址（页偏移量）</em>*</p>
<p>由于地址转换算法已经是固定的，所以 CPU 中集成了专门用来干这项工作的硬件模块，该模块称为页部件。当程序中给出一个线性地址时，页部件分析线性地址，按照以上算法，自动在页表中检索到物理地址。</p>
<p>用 <code> mov ax,[0x1234]</code>解释一下，<code>0x1234</code> 称为有效地址，它作为“段基址：段内偏移地址”中的段内偏移地址。这样段基址为 <code>0</code>，段内偏移地址为 <code>0x1234</code>，经过段部件处理后，输出的线性地址是 <code>0x1234</code>。假设打开了分页，线性地址 <code>0x1234</code> 被送入了页部件。页部件分析 <code>0x1234</code> 的高20 位，用十六进制表示高 20 位是 <code>0x00001</code>，将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从该物理地址处（页表项中）读取所映射的物理页地址：<code>0x9000</code>。线性地址的低 12 位是 <code>0x234</code>，它作为物理页的页内偏移地址与物理页地址<code>0x9000</code> 相加，和为 <code>0x9234</code>，这就是线性地址 <code>0x1234</code> 最终转换成的物理地址</p>
<p><img src="https://s2.loli.net/2022/11/06/qcdjoUCtN2iznLZ.png" alt="image.png"></p>
<h5 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h5><p>二级页表的出现很好解决了一级页表中的问题。无论是几级页表，标准页尺寸都为4KB，所以4GB线性地址空间一共会有1M个标准页，一级页表是将这1M个标准页全部放在一个页表之中，而二级页表是将这1M个标准页分为1K个页表，每个页表有1K个页表项，即每个页表大小为1K*4Byte = 4KB，恰巧为一个标准页大小。这1K个页表的起始物理地址都登记在一个页目录表中，每一项称之为页目录项（Page Directory Entry， PDE），页目录项大小同页表项一样，都用来描述一个物理页的物理地址，其大小都是 4 字节，而且最多有 1024 个页表，所以页目录表也是 4KB 大小，同样也是标准页的大小</p>
<p><img src="https://s2.loli.net/2022/11/06/V7gdlQksqh9LWyZ.png" alt="image.png"></p>
<p>在二级页表中，虚拟地址的高10位用于在一个页目录中确定某一个页表的偏移地址，用中间的10位确定页的物理地址，再用最后的12位来表示物理页的偏移地址</p>
<p>所以在二级页表中找到最终的物理地址公式为：<em><em>CR3页目录物理地址 + 虚拟地址高10位（PDE索引值） * 4 + 虚拟地址中间10位 （PTE索引值）</em> 4 + 低12位（物理页偏移地址）</em>*</p>
<p><img src="https://s2.loli.net/2022/11/07/ByioA32aTVjYx7P.png" alt="image.png"></p>
<h5 id="页目录和页表项的结构"><a href="#页目录和页表项的结构" class="headerlink" title="页目录和页表项的结构"></a>页目录和页表项的结构</h5><p><img src="https://s2.loli.net/2022/11/07/qLXPN6tsGYAQm5T.png" alt="image.png"></p>
<p>页目录和页表项都是4字节大小，但是在其中只有12~31位才是表示页表物理页地址和物理页地址，这是因为标准页的大小都为4K，低12位都是0，只需要记录高20位即可</p>
<ul>
<li>P：Present，存在位，若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。</li>
<li>RW：Read/Write，读写位，若为 1 表示可读可写，若为 0 表示可读不可写</li>
<li>US：User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问</li>
<li>PWT：Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存</li>
<li>PCD：Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存</li>
<li>A：ACCESSED：Accessed，意为访问位。若为 1 表示该页被 CPU 访问过，若为0表示该页还未访问。与段描述符中的A、P位有异曲同工之妙。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1</li>
<li>PAT：Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可</li>
<li>G：Globle，此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。由于虚拟地址转物理地址需要花费大量时间，所以需要将虚拟地址和物理地址的转换结果存储起来，存放在TLB（Translation Lookaside Buffer）中。</li>
<li>AVL：意为 Available 位，表示软件，操作系统可用该位，CPU 不理会该位的值</li>
</ul>
<h5 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h5><p>启用分页机制需要三个步骤</p>
<ol>
<li>准备好页目录和页表</li>
<li>将页表地址写入控制寄存器CR3中</li>
<li>将寄存器CR0的PG位置为1</li>
</ol>
<p>在一级页表中CR3寄存器存放的是页表的物理地址，而在二级分页中存放的是页目录的物理地址，所以CR3又称为页目录基址寄存器（Page Directory Base Register，PDBR）</p>
<p><img src="https://s2.loli.net/2022/11/07/GbLjqlnazEC8HNR.png" alt="image.png"></p>
<p>页目录的起始地址是 4KB 的整数倍，低 12 位地址全是 0。所以，只要在 cr3 寄存器的第 31～12 位中写入物理地址的高 20 位就行了，另外，cr3 寄存器的低 12 位中，除第 3 位的 PWT 位和第 4 位的 PCD 位外，其余位都没用，因为控制寄存器和通用寄存器是可以互传数据的，所以直接用<code>mov</code>指令即可，例如<code>mov cr[0~7]</code></p>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="代码设计思路"><a href="#代码设计思路" class="headerlink" title="代码设计思路"></a>代码设计思路</h5><p>设计思路与Linux类似，在用户进程4GB虚拟空间的高3GB以上的空间划分给操作系统，0 ~ 3GB是用户进程自己的虚拟空间。为了让所有的用户共享一个操作系统，必须让所有用户的3GB ~ 4GB的空间映射到同一个物理地址，这片物理地址就是操作系统的所在处。</p>
<p>分页机制得有页目录表，页目录表中的是页目录项，其中记录的是页表的物理地址及相关属性，所以还得有页表。我们实际的页目录表及页表也将按照此空间位置部署，地址的最下面是页目录表，往上依次是页表。页目录表和页表都存在于物理内存之中。页目录表的位置，放在物理地址 0x100000 处。为了让页表和页目录表紧凑一些（这不是必须的），让页表紧挨着页目录表。页目录本身占 4KB，所以第一个页表的物理地址是 0x101000，内存布局图如下</p>
<p><img src="https://s2.loli.net/2022/11/10/5RUG8lpc9bDK1tm.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/11/10/3hYfR1T8jpdXru4.png" alt="image.png"></p>
<h6 id="一些值得注意的地方"><a href="#一些值得注意的地方" class="headerlink" title="一些值得注意的地方"></a>一些值得注意的地方</h6><ol>
<li>在操作系统加载进内核之前，程序中一直运行的是loader程序，其本身的代码都在低端的1MB中，所以需要确保在分页机制下的地址和虚拟地址的的物理地址必须一一对应（即使是在分页的情况下也必须保证先运行loader），所以虚拟地址0 ~ 0xfffff必须映射到物理地址的0 ~ 0xfffff，也就是页目录表第0项对应的页表0 ~ 0xff页表项值已经确定</li>
<li>由于操作系统会被加载到低端的1MB之中，而操作系统所在的虚拟地址是在3GB往上的空间之中，所以操作系统对应的页表目录索引是0x300（高十位），也就是说页目录表第0x300项对应的页表0-0xff页表项值也已经确定</li>
<li>为了方便后面的操作系统内核的加载都放在低端的1MB内存之中，索引为768的页（0xc0000000 的高 10 位是 0x300，即十进制的 768）的虚拟地址 0xc0000000～0xc03fffff 之间的虚拟内存都指向低端 4MB 之内的物理地址，这自然包括操作系统所占的低端 1MB 物理内存。从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB，也就是内核所占的就是低端 1MB</li>
</ol>
<h5 id="mbr-S"><a href="#mbr-S" class="headerlink" title="mbr.S"></a>mbr.S</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;		;让编译器在编译之前,把boot.inc文件包含进来</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov sp,0x7c00</span><br><span class="line">	mov ax,0xb800</span><br><span class="line">	mov gs,ax</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">;利用0x06功能,上卷所有行,则可清屏</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;INT 0x10 功能号:0x06 功能描述:上卷窗口</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;输入;</span><br><span class="line">;AH 功能号:0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值</span><br><span class="line">	mov ax,0600h</span><br><span class="line">	mov bx,0700h</span><br><span class="line">	mov cx,0	;左上角:(0,0)</span><br><span class="line">	mov dx,184fh	;右下角:(80,25)</span><br><span class="line">;因为VGA文本模式中,一行只能容纳80个字符,共25行</span><br><span class="line">	; 下标从0开始,所有0x18=24,0x4f=79</span><br><span class="line">	int 10h		;int 10h</span><br><span class="line"></span><br><span class="line">	;输出字符串MBR</span><br><span class="line">	mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">	mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x02],&#x27; &#x27;</span><br><span class="line">	mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">	mov byte [gs:0x05],0xA4		;A表示绿色背景闪烁,4表示前景颜色为红色</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">	mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">	mov byte [gs:0x09],0xA4</span><br><span class="line"></span><br><span class="line">	mov eax,LOADER_START_SECTOR	;起始扇区lba地址,0x2</span><br><span class="line">	mov bx,LOADER_BASE_ADDR		;写入的地址,0x900</span><br><span class="line">	mov cx,4			;待写入的扇区数,由于loader.bin超过了512个字节，可能是多个扇区</span><br><span class="line">	call rd_disk_m_16		;以下读取程序的起始部分(一个扇区)</span><br><span class="line"></span><br><span class="line">	jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">;-------------------------------------------------------------------------------------</span><br><span class="line">					;eax=LBA扇区号</span><br><span class="line">					;bx=将数据写入的内存地址</span><br><span class="line">					;cx=读入的扇区数</span><br><span class="line">	mov esi,eax			;备份eax,因为al在out命令中会使用,会影响到eax的低8位</span><br><span class="line">	mov di,cx			;备份cx,cx在读数据的时候会使用到</span><br><span class="line">;读写硬盘</span><br><span class="line">;第一步:设置要读取的扇区数</span><br><span class="line">	mov dx,0x1f2			;虚拟硬盘属于ata0,是Primary通道,所以sector count 是由0x1f2访问</span><br><span class="line">	mov al,cl			;cl是cx的低8位,就读一个扇区,这样就能传过去了</span><br><span class="line">	out dx,al			;读取的扇区数,sector count 记录要读取的扇盘数量</span><br><span class="line"></span><br><span class="line">	mov eax,esi			;恢复eax,现在eax存的是其实扇区lba的地址,0x2,第二个扇区</span><br><span class="line"></span><br><span class="line">;第二步:将LBA地址存入 0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">	;LBA地址 7~0 位写入端口 0x1f3</span><br><span class="line">	mov dx,0x1f3			;LBA low</span><br><span class="line">	out dx,al			;eax的第8位,就是al</span><br><span class="line"></span><br><span class="line">	;LBA地址 15~8 位写入端口 0x1f4</span><br><span class="line">	mov cl,8</span><br><span class="line">	shr eax,cl			;eax右移8位,让al的数,变为eax中8位</span><br><span class="line">	mov dx,0x1f4			;LBA mid</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	;LBA地址 23~16 位写入端口 0x1f5</span><br><span class="line">	shr eax,cl			;再右移8位</span><br><span class="line">	mov dx,0x1f5			;LBA high</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	shr eax,cl			;这样al为0000</span><br><span class="line">	and al,0x0f			;lba第24~27位</span><br><span class="line">	or al,0xe0			;设置7~4位为1110,表示lba模式</span><br><span class="line">	mov dx,0x1f6			;就是拼凑出device寄存器的值</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">;第3步:向0x1f7端口写入读命令,0x20</span><br><span class="line">	mov dx,0x1f7</span><br><span class="line">	mov al,0x20</span><br><span class="line">	out dx,al			;command:0x1f7,写入命令,写入的命令是读命令</span><br><span class="line"></span><br><span class="line">;第四步:检测硬盘状态</span><br><span class="line"> .not_ready:</span><br><span class="line">	;同一端口,写时表示写入命令字,读时表示写入硬盘的状态,所以不需要更换dx的值</span><br><span class="line">	nop				;减少打扰硬盘的工作</span><br><span class="line">	in al,dx			;将Status的寄存器的值读入到al中</span><br><span class="line">	and al,0x88			;第四位为1表示硬盘控制器已准备好数据传输,第七位为1表示硬盘忙,保存第4位和第7位</span><br><span class="line">	cmp al,0x08			;若第4位为1,表示数据已经准备好了,若第7位为1,表示硬盘处于忙</span><br><span class="line">	jnz .not_ready			;若未准备好,继续等,判断结果是否为0</span><br><span class="line"></span><br><span class="line">;第5步,从0x1f0端口读数据</span><br><span class="line">	mov ax,di			;这个时候di存的是上面备份的cx,及时要读取的扇区的数量</span><br><span class="line">	mov dx,256			;每次in操作只读取两个字节,根据读入的数据总量(扇区数*512字节)</span><br><span class="line">	mul dx				;dx*ax就是总数量/2,然后将值送到cx中,cx就是要in的次数</span><br><span class="line">	mov cx,ax			;di为要读取的扇区数,一个扇区有512个字节,每次读入一个字,共需要di*512/2次,所以di*256</span><br><span class="line"></span><br><span class="line">	mov dx,0x1f0</span><br><span class="line"> .go_on_read:</span><br><span class="line">	in ax,dx			;读入到ax中</span><br><span class="line">	mov [bx],ax			;读入到bx指向的内存</span><br><span class="line">	add bx,2			;每次读入2个字节</span><br><span class="line">	loop .go_on_read		;cx是循环的次数</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	times 510-($-$$) db 0</span><br><span class="line">	db 0x55,0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="loader-S"><a href="#loader-S" class="headerlink" title="loader.S"></a>loader.S</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line">   </span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ; limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化页内存位图</span><br><span class="line">   call setup_page</span><br><span class="line"></span><br><span class="line">   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置</span><br><span class="line"></span><br><span class="line">   ;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2]  </span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br><span class="line">					      ;段描述符的高4字节的最高位是段基址的31~24位</span><br><span class="line"></span><br><span class="line">   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line"></span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   ;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr]             ; 重新加载</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &#x27;V&#x27;     ;视频段段基址已经被更新,用字符v表示virtual addr</span><br><span class="line"></span><br><span class="line">   jmp $</span><br><span class="line"></span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">setup_page:</span><br><span class="line">;先把页目录占用的空间逐字节清0</span><br><span class="line">   mov ecx, 4096</span><br><span class="line">   mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">   mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">   inc esi</span><br><span class="line">   loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">;开始创建页目录项(PDE)</span><br><span class="line">.create_pde:				     ; 创建Page Directory Entry</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性</span><br><span class="line">   mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><span class="line"></span><br><span class="line">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="line">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="line">;   这是为将地址映射为内核地址做准备</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P	     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br><span class="line">					     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br><span class="line">   sub eax, 0x1000</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建页表项(PTE)</span><br><span class="line">   mov ecx, 256				     ; 1M低端内存 / 每页大小4k = 256</span><br><span class="line">   mov esi, 0</span><br><span class="line">   mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US=1,RW=1,P=1</span><br><span class="line">.create_pte:				     ; 创建Page Table Entry</span><br><span class="line">   mov [ebx+esi*4],edx			     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br><span class="line">   add edx,4096</span><br><span class="line">   inc esi</span><br><span class="line">   loop .create_pte</span><br><span class="line"></span><br><span class="line">;创建内核其它页表的PDE</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x2000 		     ; 此时eax为第二个页表的位置</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性US,RW和P位都为1</span><br><span class="line">   mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov ecx, 254			     ; 范围为第769~1022的所有目录项数量</span><br><span class="line">   mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">   mov [ebx+esi*4], eax</span><br><span class="line">   inc esi</span><br><span class="line">   add eax, 0x1000</span><br><span class="line">   loop .create_kernel_pde</span><br><span class="line">   ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="boot-inc"><a href="#boot-inc" class="headerlink" title="boot.inc"></a>boot.inc</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;-------------	 loader和kernel   ----------</span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR equ 0x900 </span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line">PAGE_DIR_TABLE_POS equ 0x100000</span><br><span class="line"></span><br><span class="line">;--------------   gdt描述符属性  -------------</span><br><span class="line">DESC_G_4K   equ	  1_00000000000000000000000b   </span><br><span class="line">DESC_D_32   equ	   1_0000000000000000000000b</span><br><span class="line">DESC_L	    equ	    0_000000000000000000000b	;  64位代码标记，此处标记为0便可。</span><br><span class="line">DESC_AVL    equ	     0_00000000000000000000b	;  cpu不用此位，暂置为0  </span><br><span class="line">DESC_LIMIT_CODE2  equ 1111_0000000000000000b</span><br><span class="line">DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2  equ 0000_000000000000000b</span><br><span class="line">DESC_P	    equ		  1_000000000000000b</span><br><span class="line">DESC_DPL_0  equ		   00_0000000000000b</span><br><span class="line">DESC_DPL_1  equ		   01_0000000000000b</span><br><span class="line">DESC_DPL_2  equ		   10_0000000000000b</span><br><span class="line">DESC_DPL_3  equ		   11_0000000000000b</span><br><span class="line">DESC_S_CODE equ		     1_000000000000b</span><br><span class="line">DESC_S_DATA equ	  DESC_S_CODE</span><br><span class="line">DESC_S_sys  equ		     0_000000000000b</span><br><span class="line">DESC_TYPE_CODE  equ	      1000_00000000b	;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  </span><br><span class="line">DESC_TYPE_DATA  equ	      0010_00000000b	;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00</span><br><span class="line">DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line">DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b</span><br><span class="line"></span><br><span class="line">;--------------   选择子属性  ---------------</span><br><span class="line">RPL0  equ   00b</span><br><span class="line">RPL1  equ   01b</span><br><span class="line">RPL2  equ   10b</span><br><span class="line">RPL3  equ   11b</span><br><span class="line">TI_GDT	 equ   000b</span><br><span class="line">TI_LDT	 equ   100b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;----------------   页表相关属性    --------------</span><br><span class="line">PG_P  equ   1b</span><br><span class="line">PG_RW_R	 equ  00b </span><br><span class="line">PG_RW_W	 equ  10b </span><br><span class="line">PG_US_S	 equ  000b </span><br><span class="line">PG_US_U	 equ  100b </span><br></pre></td></tr></table></figure>



<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include/ -o mbr.bin mbr.S </span><br><span class="line">nasm -I include/ -o loader.bin loader.S</span><br><span class="line"></span><br><span class="line">dd if=boot/mbr.bin of=../a.img bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=boot/loader.bin of=../a.img bs=512 count=4 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure>



<h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="https://s2.loli.net/2022/11/14/ZbInWVAMXChpkz1.png" alt="image.png"></p>
<h4 id="关于地址映射"><a href="#关于地址映射" class="headerlink" title="关于地址映射"></a>关于地址映射</h4><p>根据bochs中的调试指令<code> info tab</code>可以查看虚拟地址映射的物理地址，图中左边是虚拟地址，右边是物理地址</p>
<p><img src="https://s2.loli.net/2022/11/14/DP2F9gpXzBmdxle.png" alt="image.png"></p>
<p>第一条映射关系相当明显，映射了第0个页目录项的物理地址</p>
<p>第二条映射关系是第768个页表完成的映射关系，它所映射的也是第0个页目录项的物理地址，所以和第一条映射的物理地址相同</p>
<p>第三条映射关系中0xffc00000，负责表示页表项索引的高十位全部为1，而表示页表的索引中间10位全部为0，所以他指向的是最后一个页表（即第1023个页表）的第0项，而最后一个页表项中存放的是第0个页表的物理地址，所以指向了第0个页表，其值是 0x101000，此值被认为是最终的物理页地址。剩下的12就是偏移量，加上去就能得到0x00101fff，即最终的映射的物理地址是0x00101000~0x00101fff</p>
<p>第四条映射关系0xfff00000 的高 10 位依然为 0x3ff，中间 10 位是 1100000000b=0x300，这是第 768 个页目录项，该页目录项指向的页表与第 0 个页目录项指向的页表相同。所以虚拟地址 0xfff00000 映射为物理地址0x00101000 成立，即最终的映射的物理地址是0x00101000~0x00101fff</p>
<p>第五条映射关系0xfffff000高 10 位为 0x3ff，中间10位是0x3ff，映射的是第1023页的1023项，由于1023页目录项指向了该页目录的首地址，而页目录的首地址映射的是自己的物理地址，所以这里的前20位映射相当于是将页目录看作是一个页表进行映射，所以最低物理地址就是页目录的物理地址0x00100000，最大物理地址0x00100000+2<sup>12</sup>-1=0x00100fff。由此可以得出结论：如果虚拟地址的高 20 位为 0xfffff，经过我们的页目录表映射，将会访问到页目录表自己的物理地址。</p>
<h5 id="用虚拟地址获取页表中各数据类型的方法总结"><a href="#用虚拟地址获取页表中各数据类型的方法总结" class="headerlink" title="用虚拟地址获取页表中各数据类型的方法总结"></a>用虚拟地址获取页表中各数据类型的方法总结</h5><ul>
<li>获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也是页目录表中第 0 个页目录项自身的物理地址</li>
<li>访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录项的索引乘以 4 的积</li>
<li>访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff（第768个页目录项，指向的是页目录的物理地址），目的是获取页目录表物理地址。中间 10 位为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页表项，它必须是已经乘以 4 后的值</li>
</ul>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>虽然分表机制解决了内存碎片等一系列问题，但是需要寄存器和内存花费更多的时间去寻址，为了解决这个问题，还是采用了缓存思想 ，添加了一个高速缓存专门用于虚拟地址页框和存储页框物理地址，这个高速缓存称之为快表（ TLB，Translation Lookaside Buffer）</p>
<p>高速缓存由于成本等原因，容量一般都很小，TLB 也是，因此 TLB 中的数据只是当前任务的部分页表，而且只有 P 位为 1 的页表项才有资格在 TLB 中，如果 TLB 被装满了，需要将很少使用的条目换出。TLB 里面存储的是程序运行所依赖的指令和数据的内存地址，任意时刻都必须保证地址的有效性，否则程序必然出错，所以 TLB 必须实时更新</p>
<p>TLB 中的条目是虚拟地址的高 20 位到物理地址高 20 位的映射结果，实际上就是从虚拟页框到物理页框的映射。除此之外 TLB中还有一些属性位，比如页表项的 RW 属性</p>
<p><img src="https://s2.loli.net/2022/11/14/kan7CTbEh6OU8oY.png" alt="image.png"></p>
<p>TLB 对开发人员不可见，但是开发人员依旧可以使用间接方法来改变TLB</p>
<ul>
<li>重新加载CR3（感觉像清空流水线）</li>
<li>使用<code>invlpg</code>指令，如<code>invlpg [0x1234]</code>因为其中的<code>0x1234</code>并非立即数数，所以得采用<code>[]</code></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">fLo4Tc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/">http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F/">操作系统真相还原</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src="https://s2.loli.net/2022/10/31/vypDPWC2Fz7dOaI.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">保护模式入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" title="保护模式入门"><img class="cover" src="https://s2.loli.net/2022/10/31/vypDPWC2Fz7dOaI.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-29</div><div class="title">保护模式入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/10/31/YCmjBOJQUDPzeLE.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fLo4Tc</div><div class="author-info__description">就当是写点东西吧</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/floatczr"><i class="fab fa-github"></i><span>empty profile</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/floatczr" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">保护模式进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">获取内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0xe820%E5%AD%90%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">0xe820子功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ARDS"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">ARDS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A80xe820"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">调用0xe820</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0xe801%E5%AD%90%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">0xe801子功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x88%E5%AD%90%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">0x88子功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">1.2.</span> <span class="toc-text">分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">物理地址、虚拟地址、线性地址和逻辑地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">虚拟地址和线性地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">逻辑地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">地址之间的关系图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">一级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">一级页表存在的问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%EF%BC%89%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">虚拟地址（线性地址）和物理地址的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">二级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%92%8C%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">页目录和页表项的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">启用分页机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">代码部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">代码设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">一些值得注意的地方</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mbr-S"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">mbr.S</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#loader-S"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">loader.S</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#boot-inc"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">boot.inc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%9B%BE"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">效果图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">关于地址映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E9%A1%B5%E8%A1%A8%E4%B8%AD%E5%90%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">用虚拟地址获取页表中各数据类型的方法总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">快表</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/" title="保护模式进阶"><img src="https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="保护模式进阶"/></a><div class="content"><a class="title" href="/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/" title="保护模式进阶">保护模式进阶</a><time datetime="2022-11-03T07:20:39.000Z" title="Created 2022-11-03 15:20:39">2022-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" title="保护模式入门"><img src="https://s2.loli.net/2022/10/31/vypDPWC2Fz7dOaI.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="保护模式入门"/></a><div class="content"><a class="title" href="/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" title="保护模式入门">保护模式入门</a><time datetime="2022-10-29T09:07:41.000Z" title="Created 2022-10-29 17:07:41">2022-10-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/11/14/wtFZ6YRfq9Cp1BT.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By fLo4Tc</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="1,0" data-fontsize="10px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>