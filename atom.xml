<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>floatc.rar</title>
  
  <subtitle>finally</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-14T11:04:40.536Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fLo4Tc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保护模式进阶</title>
    <link href="http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2022/11/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/</id>
    <published>2022-11-03T07:20:39.000Z</published>
    <updated>2022-11-14T11:04:40.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护模式进阶"><a href="#保护模式进阶" class="headerlink" title="保护模式进阶"></a>保护模式进阶</h2><h3 id="获取内存"><a href="#获取内存" class="headerlink" title="获取内存"></a>获取内存</h3><p>在linux中有许多方法获取内存容量，其本质上是调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的 3 个子功能。</p><ul><li>EAX=0xE820：遍历主机上全部内存。</li><li>AX=0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。</li><li>AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。</li></ul><h4 id="0xe820子功能"><a href="#0xe820子功能" class="headerlink" title="0xe820子功能"></a>0xe820子功能</h4><h5 id="ARDS"><a href="#ARDS" class="headerlink" title="ARDS"></a>ARDS</h5><p>BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同，BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS）。</p><p><img src="https://s2.loli.net/2022/11/03/jIW1XrDbaRindM2.png" alt="image.png"></p><p>地址范围描述符大小是4个字节，共5个字段，一共20个字节，每次调用中断0x15时就会返回这样一个奇似描述符的数据结构。ADRS用高低共64位的地址来描述这段内存的基地址，又用高低各32位共64位的地址来描述这段内存的长度，最后用Type来标识这段内存的类型,这里所谓的类型是说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。</p><p><img src="https://s2.loli.net/2022/11/03/9PRcY8xD67tZJSb.png" alt="image.png"></p><p>由于在 32 位环境下工作，所以在 ARDS 结构属性中，我们只用到低 32 位属性。BaseAddrLow+LengthLow 是一片内存区域上限，单位是字节。</p><h5 id="调用0xe820"><a href="#调用0xe820" class="headerlink" title="调用0xe820"></a>调用0xe820</h5><p>此功能的调用步骤分为三步</p><ol><li><p>填写好“调用前输入”中列出的寄存器</p></li><li><p>执行中断调用 int 0x15</p></li><li><p>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</p></li></ol><p><img src="https://s2.loli.net/2022/11/03/MGao7izyNXp4fJw.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/11/03/3bsH5VZtTjSRrNy.png" alt="image.png"></p><h4 id="0xe801子功能"><a href="#0xe801子功能" class="headerlink" title="0xe801子功能"></a>0xe801子功能</h4><p>0xe801子功能最多只能识别4GB内存，低于 15MB 的内存以 1KB 为单位大小来记录，单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的最大容量=AX * 1024 = 0x3c00 = 15MB。16MB～4GB 是以 64KB 为单位大小来记录的，单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的。</p><p><img src="https://s2.loli.net/2022/11/03/7VzIXU34jZn5Pvk.png" alt="image.png"></p><p>此中断的调用步骤如下：</p><ol><li><p>将 AX 寄存器写入 0xE801</p></li><li><p>执行中断调用 int 0x15</p></li><li><p>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</p></li></ol><h4 id="0x88子功能"><a href="#0x88子功能" class="headerlink" title="0x88子功能"></a>0x88子功能</h4><p>0x88子功能最多只能识别64MB的内存，当内存大于64MB是只会显示63MB，因为此功能只会显示1MB之上的内存，不包括这1MB，所以在使用之时要加上这1MB</p><p><img src="https://s2.loli.net/2022/11/03/sUfy6Rq9Hxo3Q1r.png" alt="image.png"></p><p>此中断的调用步骤如下：</p><ol><li>将 AX 寄存器写入 0x88</li><li>执行中断调用 int 0x15</li><li>在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果</li></ol><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="物理地址、虚拟地址、线性地址和逻辑地址"><a href="#物理地址、虚拟地址、线性地址和逻辑地址" class="headerlink" title="物理地址、虚拟地址、线性地址和逻辑地址"></a>物理地址、虚拟地址、线性地址和逻辑地址</h4><h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><p>物理地址就是物理上真正存在的地址，无论地址怎样变化，cpu最终访问的一定是物理地址。在实模式下，“段基址+偏移地址”直接输出的就是物理地址</p><h5 id="虚拟地址和线性地址"><a href="#虚拟地址和线性地址" class="headerlink" title="虚拟地址和线性地址"></a>虚拟地址和线性地址</h5><p>在保护模式下，“段基址+段内偏移地址”称为线性地址。选择子指向段描述符，描述符中有段的段基址，而段内偏移地址就是要访问地址的低位。若未开启分页，则该线性地址等同于物理地址。若开启了分页功能，就又称之为虚拟地址，虚拟地址要经过专门的CPU部件才会转化为真正的物理地址</p><h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><p>无论在实模式或是保护模式下，段内偏移地址又称为有效地址、也成为逻辑地址，也就是程序员可见的地址。</p><h5 id="地址之间的关系图"><a href="#地址之间的关系图" class="headerlink" title="地址之间的关系图"></a>地址之间的关系图</h5><p><img src="https://s2.loli.net/2022/11/05/X9moc7Z46IdylUH.png" alt="image.png"></p><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>分页机制是建立在分段机制之上的。在保护模式中段寄存器中的内容是选择子，但选择子最终就是为了要找到段基址，其内存访问的核心机制依然是“段基址：段内偏移地址”，这两个地址在相加之后才是绝对地址，在未开启分页时，此地址直接等同于物理地址。</p><p><img src="https://s2.loli.net/2022/11/06/azBv9cP8HyqM6tK.png" alt="image.png"></p><p>开启分页之后，段部件输出的地址不再等同于物理地址，称之为虚拟地址，它是逻辑上的，是假的。</p><p><img src="https://s2.loli.net/2022/11/06/UcQ9G6s1Shgp7yJ.png" alt="image.png"></p><p>分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续，分页机制的作用有两方面：</p><ul><li><p>将线性地址转换成物理地址</p></li><li><p>用大小相等的页代替大小不等的段</p></li></ul><p><img src="https://s2.loli.net/2022/11/06/bKIiCvfwAGajp8Z.png" alt="image.png"></p><p>每加载一个进程，操作系统按照进程中各段的起始范围，在进程自己的 4GB 虚拟地址空间中寻找可用空间分配内存段，此虚拟地址空间可以是页表，也可以是操作系统维护的某种数据结构，此阶段的分配是逻辑上的，并没有真正写入物理内存。在分页机制下，代码段和数据段在逻辑上被拆分为以页为单位的小内存块。接着操作系统开始为这些虚拟内存分配真正的物理页地址，并在页表中登记这些物理页地址，完成虚拟页到物理页的映射</p><h5 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h5><p>假设表中有4G个页表项，则32位的地址要用4字节的页表项来存储，页表总共大小位4Byte * 4G = 16GB，这种存储方法实际上就是将4G个页分配成4G个内存块，每个内存块为1字节大小，光页表就有16GB，得不偿失。所以解决方法就是少分几个页，将每个页的尺寸变大，CPU中采用的页就是4KB，所以4GB空间一共有4 * 1024 * 1024=1048576个页表项，也就是说页表中也需要1048576个页表项，这个页表被称为一级页表</p><p><img src="https://s2.loli.net/2022/11/06/2Ojh4Bn8tEIXlvG.png" alt="页表和物理地址"></p><p>由于页大小是4KB，所以页表项中的物理地址都是 4k 的整数倍，故用十六进制表示的地址，低 3 位都是 0。就拿第3 个页表项来说，其值为 0x3000，表示该页对应的物理地址是 0x3000。</p><h6 id="一级页表存在的问题"><a href="#一级页表存在的问题" class="headerlink" title="一级页表存在的问题"></a>一级页表存在的问题</h6><ol><li>一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB，用户进程要占用低 3GB</li><li>一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话，便是 4MB 大小，但是每个进程都有自己的页表，进程一多，光是页表占用的空间就相当大了</li></ol><h5 id="虚拟地址（线性地址）和物理地址的转换"><a href="#虚拟地址（线性地址）和物理地址的转换" class="headerlink" title="虚拟地址（线性地址）和物理地址的转换"></a>虚拟地址（线性地址）和物理地址的转换</h5><p>分页机制打开前要将页表地址加载到控制寄存器 cr3 中，这是启用分页机制的先决条件之一。所以，在打开分页机制前加载到寄存器 cr3 中的是页表的物理地址，页表中页表项的地址自然也是物理地址了。</p><p>一个页表项对应一个页，所以，用线性地址的高 20 位作为页表项的索引，每个页表项要占用 4 字节大小，所以这高 20 位的索引乘以 4 后才是该页表项相对于页表物理地址的字节偏移量。用 cr3 寄存器中的页表物理地址加上此偏移量便是该页表项的物理地址，从该页表项中得到映射的物理页地址，然后用线性地址的低 12 位与该物理页地址相加，所得的地址之和便是最终要访问的物理地址。</p><p>总结下就是：<em><em>页表项的物理地址 = CR3中页表的物理地址（物理起始地址） + 高20位虚拟地址 （页索引）</em> 4 （每个页表项大小）+ 低12位虚拟地址（页偏移量）</em>*</p><p>由于地址转换算法已经是固定的，所以 CPU 中集成了专门用来干这项工作的硬件模块，该模块称为页部件。当程序中给出一个线性地址时，页部件分析线性地址，按照以上算法，自动在页表中检索到物理地址。</p><p>用 <code> mov ax,[0x1234]</code>解释一下，<code>0x1234</code> 称为有效地址，它作为“段基址：段内偏移地址”中的段内偏移地址。这样段基址为 <code>0</code>，段内偏移地址为 <code>0x1234</code>，经过段部件处理后，输出的线性地址是 <code>0x1234</code>。假设打开了分页，线性地址 <code>0x1234</code> 被送入了页部件。页部件分析 <code>0x1234</code> 的高20 位，用十六进制表示高 20 位是 <code>0x00001</code>，将此项作为页表项索引，再将该索引乘以 4 后加上 cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从该物理地址处（页表项中）读取所映射的物理页地址：<code>0x9000</code>。线性地址的低 12 位是 <code>0x234</code>，它作为物理页的页内偏移地址与物理页地址<code>0x9000</code> 相加，和为 <code>0x9234</code>，这就是线性地址 <code>0x1234</code> 最终转换成的物理地址</p><p><img src="https://s2.loli.net/2022/11/06/qcdjoUCtN2iznLZ.png" alt="image.png"></p><h5 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h5><p>二级页表的出现很好解决了一级页表中的问题。无论是几级页表，标准页尺寸都为4KB，所以4GB线性地址空间一共会有1M个标准页，一级页表是将这1M个标准页全部放在一个页表之中，而二级页表是将这1M个标准页分为1K个页表，每个页表有1K个页表项，即每个页表大小为1K*4Byte = 4KB，恰巧为一个标准页大小。这1K个页表的起始物理地址都登记在一个页目录表中，每一项称之为页目录项（Page Directory Entry， PDE），页目录项大小同页表项一样，都用来描述一个物理页的物理地址，其大小都是 4 字节，而且最多有 1024 个页表，所以页目录表也是 4KB 大小，同样也是标准页的大小</p><p><img src="https://s2.loli.net/2022/11/06/V7gdlQksqh9LWyZ.png" alt="image.png"></p><p>在二级页表中，虚拟地址的高10位用于在一个页目录中确定某一个页表的偏移地址，用中间的10位确定页的物理地址，再用最后的12位来表示物理页的偏移地址</p><p>所以在二级页表中找到最终的物理地址公式为：<em><em>CR3页目录物理地址 + 虚拟地址高10位（PDE索引值） * 4 + 虚拟地址中间10位 （PTE索引值）</em> 4 + 低12位（物理页偏移地址）</em>*</p><p><img src="https://s2.loli.net/2022/11/07/ByioA32aTVjYx7P.png" alt="image.png"></p><h5 id="页目录和页表项的结构"><a href="#页目录和页表项的结构" class="headerlink" title="页目录和页表项的结构"></a>页目录和页表项的结构</h5><p><img src="https://s2.loli.net/2022/11/07/qLXPN6tsGYAQm5T.png" alt="image.png"></p><p>页目录和页表项都是4字节大小，但是在其中只有12~31位才是表示页表物理页地址和物理页地址，这是因为标准页的大小都为4K，低12位都是0，只需要记录高20位即可</p><ul><li>P：Present，存在位，若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。</li><li>RW：Read/Write，读写位，若为 1 表示可读可写，若为 0 表示可读不可写</li><li>US：User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问</li><li>PWT：Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存</li><li>PCD：Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存</li><li>A：ACCESSED：Accessed，意为访问位。若为 1 表示该页被 CPU 访问过，若为0表示该页还未访问。与段描述符中的A、P位有异曲同工之妙。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1</li><li>PAT：Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可</li><li>G：Globle，此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。由于虚拟地址转物理地址需要花费大量时间，所以需要将虚拟地址和物理地址的转换结果存储起来，存放在TLB（Translation Lookaside Buffer）中。</li><li>AVL：意为 Available 位，表示软件，操作系统可用该位，CPU 不理会该位的值</li></ul><h5 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h5><p>启用分页机制需要三个步骤</p><ol><li>准备好页目录和页表</li><li>将页表地址写入控制寄存器CR3中</li><li>将寄存器CR0的PG位置为1</li></ol><p>在一级页表中CR3寄存器存放的是页表的物理地址，而在二级分页中存放的是页目录的物理地址，所以CR3又称为页目录基址寄存器（Page Directory Base Register，PDBR）</p><p><img src="https://s2.loli.net/2022/11/07/GbLjqlnazEC8HNR.png" alt="image.png"></p><p>页目录的起始地址是 4KB 的整数倍，低 12 位地址全是 0。所以，只要在 cr3 寄存器的第 31～12 位中写入物理地址的高 20 位就行了，另外，cr3 寄存器的低 12 位中，除第 3 位的 PWT 位和第 4 位的 PCD 位外，其余位都没用，因为控制寄存器和通用寄存器是可以互传数据的，所以直接用<code>mov</code>指令即可，例如<code>mov cr[0~7]</code></p><h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="代码设计思路"><a href="#代码设计思路" class="headerlink" title="代码设计思路"></a>代码设计思路</h5><p>设计思路与Linux类似，在用户进程4GB虚拟空间的高3GB以上的空间划分给操作系统，0<del>3GB是用户进程自己的虚拟空间。为了让所有的用户共享一个操作系统，必须让所有用户的3GB</del>4GB的空间映射到同一个物理地址，这片物理地址就是操作系统的所在处。</p><p>分页机制得有页目录表，页目录表中的是页目录项，其中记录的是页表的物理地址及相关属性，所以还得有页表。我们实际的页目录表及页表也将按照此空间位置部署，地址的最下面是页目录表，往上依次是页表。页目录表和页表都存在于物理内存之中。页目录表的位置，放在物理地址 0x100000 处。为了让页表和页目录表紧凑一些（这不是必须的），让页表紧挨着页目录表。页目录本身占 4KB，所以第一个页表的物理地址是 0x101000，内存布局图如下</p><p><img src="https://s2.loli.net/2022/11/10/5RUG8lpc9bDK1tm.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/11/10/3hYfR1T8jpdXru4.png" alt="image.png"></p><h6 id="一些值得注意的地方"><a href="#一些值得注意的地方" class="headerlink" title="一些值得注意的地方"></a>一些值得注意的地方</h6><ol><li>在操作系统加载进内核之前，程序中一直运行的是loader程序，其本身的代码都在低端的1MB中，所以需要确保在分页机制下的地址和虚拟地址的的物理地址必须一一对应（即使是在分页的情况下也必须保证先运行loader），所以虚拟地址0<del>0xfffff必须映射到物理地址的0-0xfffff，也就是页目录表第0项对应的页表0</del>0xff页表项值已经确定</li><li>由于操作系统会被加载到低端的1MB之中，而操作系统所在的虚拟地址是在3GB往上的空间之中，所以操作系统对应的页表目录索引是0x300（高十位），也就是说页目录表第0x300项对应的页表0-0xff页表项值也已经确定</li><li>为了方便后面的操作系统内核的加载都放在低端的1MB内存之中，索引为768的页（0xc0000000 的高 10 位是 0x300，即十进制的 768）的虚拟地址 0xc0000000～0xc03fffff 之间的虚拟内存都指向低端 4MB 之内的物理地址，这自然包括操作系统所占的低端 1MB 物理内存。从而实现了操作系统高 3GB 以上的虚拟地址对应到了低端 1MB，也就是内核所占的就是低端 1MB</li></ol><h5 id="mbr-S"><a href="#mbr-S" class="headerlink" title="mbr.S"></a>mbr.S</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;;让编译器在编译之前,把boot.inc文件包含进来</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">;利用0x06功能,上卷所有行,则可清屏</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;INT 0x10 功能号:0x06 功能描述:上卷窗口</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;输入;</span><br><span class="line">;AH 功能号:0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值</span><br><span class="line">mov ax,0600h</span><br><span class="line">mov bx,0700h</span><br><span class="line">mov cx,0;左上角:(0,0)</span><br><span class="line">mov dx,184fh;右下角:(80,25)</span><br><span class="line">;因为VGA文本模式中,一行只能容纳80个字符,共25行</span><br><span class="line">; 下标从0开始,所有0x18=24,0x4f=79</span><br><span class="line">int 10h;int 10h</span><br><span class="line"></span><br><span class="line">;输出字符串MBR</span><br><span class="line">mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02],&#x27; &#x27;</span><br><span class="line">mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">mov byte [gs:0x05],0xA4;A表示绿色背景闪烁,4表示前景颜色为红色</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">mov byte [gs:0x09],0xA4</span><br><span class="line"></span><br><span class="line">mov eax,LOADER_START_SECTOR;起始扇区lba地址,0x2</span><br><span class="line">mov bx,LOADER_BASE_ADDR;写入的地址,0x900</span><br><span class="line">mov cx,4;待写入的扇区数,由于loader.bin超过了512个字节，可能是多个扇区</span><br><span class="line">call rd_disk_m_16;以下读取程序的起始部分(一个扇区)</span><br><span class="line"></span><br><span class="line">jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">;-------------------------------------------------------------------------------------</span><br><span class="line">;eax=LBA扇区号</span><br><span class="line">;bx=将数据写入的内存地址</span><br><span class="line">;cx=读入的扇区数</span><br><span class="line">mov esi,eax;备份eax,因为al在out命令中会使用,会影响到eax的低8位</span><br><span class="line">mov di,cx;备份cx,cx在读数据的时候会使用到</span><br><span class="line">;读写硬盘</span><br><span class="line">;第一步:设置要读取的扇区数</span><br><span class="line">mov dx,0x1f2;虚拟硬盘属于ata0,是Primary通道,所以sector count 是由0x1f2访问</span><br><span class="line">mov al,cl;cl是cx的低8位,就读一个扇区,这样就能传过去了</span><br><span class="line">out dx,al;读取的扇区数,sector count 记录要读取的扇盘数量</span><br><span class="line"></span><br><span class="line">mov eax,esi;恢复eax,现在eax存的是其实扇区lba的地址,0x2,第二个扇区</span><br><span class="line"></span><br><span class="line">;第二步:将LBA地址存入 0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">;LBA地址 7~0 位写入端口 0x1f3</span><br><span class="line">mov dx,0x1f3;LBA low</span><br><span class="line">out dx,al;eax的第8位,就是al</span><br><span class="line"></span><br><span class="line">;LBA地址 15~8 位写入端口 0x1f4</span><br><span class="line">mov cl,8</span><br><span class="line">shr eax,cl;eax右移8位,让al的数,变为eax中8位</span><br><span class="line">mov dx,0x1f4;LBA mid</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;LBA地址 23~16 位写入端口 0x1f5</span><br><span class="line">shr eax,cl;再右移8位</span><br><span class="line">mov dx,0x1f5;LBA high</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">shr eax,cl;这样al为0000</span><br><span class="line">and al,0x0f;lba第24~27位</span><br><span class="line">or al,0xe0;设置7~4位为1110,表示lba模式</span><br><span class="line">mov dx,0x1f6;就是拼凑出device寄存器的值</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;第3步:向0x1f7端口写入读命令,0x20</span><br><span class="line">mov dx,0x1f7</span><br><span class="line">mov al,0x20</span><br><span class="line">out dx,al;command:0x1f7,写入命令,写入的命令是读命令</span><br><span class="line"></span><br><span class="line">;第四步:检测硬盘状态</span><br><span class="line"> .not_ready:</span><br><span class="line">;同一端口,写时表示写入命令字,读时表示写入硬盘的状态,所以不需要更换dx的值</span><br><span class="line">nop;减少打扰硬盘的工作</span><br><span class="line">in al,dx;将Status的寄存器的值读入到al中</span><br><span class="line">and al,0x88;第四位为1表示硬盘控制器已准备好数据传输,第七位为1表示硬盘忙,保存第4位和第7位</span><br><span class="line">cmp al,0x08;若第4位为1,表示数据已经准备好了,若第7位为1,表示硬盘处于忙</span><br><span class="line">jnz .not_ready;若未准备好,继续等,判断结果是否为0</span><br><span class="line"></span><br><span class="line">;第5步,从0x1f0端口读数据</span><br><span class="line">mov ax,di;这个时候di存的是上面备份的cx,及时要读取的扇区的数量</span><br><span class="line">mov dx,256;每次in操作只读取两个字节,根据读入的数据总量(扇区数*512字节)</span><br><span class="line">mul dx;dx*ax就是总数量/2,然后将值送到cx中,cx就是要in的次数</span><br><span class="line">mov cx,ax;di为要读取的扇区数,一个扇区有512个字节,每次读入一个字,共需要di*512/2次,所以di*256</span><br><span class="line"></span><br><span class="line">mov dx,0x1f0</span><br><span class="line"> .go_on_read:</span><br><span class="line">in ax,dx;读入到ax中</span><br><span class="line">mov [bx],ax;读入到bx指向的内存</span><br><span class="line">add bx,2;每次读入2个字节</span><br><span class="line">loop .go_on_read;cx是循环的次数</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="loader-S"><a href="#loader-S" class="headerlink" title="loader.S"></a>loader.S</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line">   </span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007       ; limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -1 </span><br><span class="line">   times 60 dq 0 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]      ;length_low</span><br><span class="line">   add ebx, 20      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx</span><br><span class="line">   mov ecx, 0x10000;0x10000十进制为64KB</span><br><span class="line">   mul ecx;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16     ;把dx移到高16位</span><br><span class="line">   or edx, eax     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化页内存位图</span><br><span class="line">   call setup_page</span><br><span class="line"></span><br><span class="line">   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr]      ; 存储到原来gdt所有的位置</span><br><span class="line"></span><br><span class="line">   ;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2]  </span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br><span class="line">      ;段描述符的高4字节的最高位是段基址的31~24位</span><br><span class="line"></span><br><span class="line">   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line"></span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   ;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr]             ; 重新加载</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &#x27;V&#x27;     ;视频段段基址已经被更新,用字符v表示virtual addr</span><br><span class="line"></span><br><span class="line">   jmp $</span><br><span class="line"></span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">setup_page:</span><br><span class="line">;先把页目录占用的空间逐字节清0</span><br><span class="line">   mov ecx, 4096</span><br><span class="line">   mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">   mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">   inc esi</span><br><span class="line">   loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">;开始创建页目录项(PDE)</span><br><span class="line">.create_pde:     ; 创建Page Directory Entry</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x1000      ; 此时eax为第一个页表的位置及属性</span><br><span class="line">   mov ebx, eax     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><span class="line"></span><br><span class="line">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="line">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="line">;   这是为将地址映射为内核地址做准备</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br><span class="line">     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br><span class="line">   sub eax, 0x1000</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 4092], eax     ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建页表项(PTE)</span><br><span class="line">   mov ecx, 256     ; 1M低端内存 / 每页大小4k = 256</span><br><span class="line">   mov esi, 0</span><br><span class="line">   mov edx, PG_US_U | PG_RW_W | PG_P     ; 属性为7,US=1,RW=1,P=1</span><br><span class="line">.create_pte:     ; 创建Page Table Entry</span><br><span class="line">   mov [ebx+esi*4],edx     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br><span class="line">   add edx,4096</span><br><span class="line">   inc esi</span><br><span class="line">   loop .create_pte</span><br><span class="line"></span><br><span class="line">;创建内核其它页表的PDE</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x2000      ; 此时eax为第二个页表的位置</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性US,RW和P位都为1</span><br><span class="line">   mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov ecx, 254     ; 范围为第769~1022的所有目录项数量</span><br><span class="line">   mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">   mov [ebx+esi*4], eax</span><br><span class="line">   inc esi</span><br><span class="line">   add eax, 0x1000</span><br><span class="line">   loop .create_kernel_pde</span><br><span class="line">   ret</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="boot-inc"><a href="#boot-inc" class="headerlink" title="boot.inc"></a>boot.inc</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;------------- loader和kernel   ----------</span><br><span class="line"></span><br><span class="line">LOADER_BASE_ADDR equ 0x900 </span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line">PAGE_DIR_TABLE_POS equ 0x100000</span><br><span class="line"></span><br><span class="line">;--------------   gdt描述符属性  -------------</span><br><span class="line">DESC_G_4K   equ  1_00000000000000000000000b   </span><br><span class="line">DESC_D_32   equ   1_0000000000000000000000b</span><br><span class="line">DESC_L    equ    0_000000000000000000000b;  64位代码标记，此处标记为0便可。</span><br><span class="line">DESC_AVL    equ     0_00000000000000000000b;  cpu不用此位，暂置为0  </span><br><span class="line">DESC_LIMIT_CODE2  equ 1111_0000000000000000b</span><br><span class="line">DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2  equ 0000_000000000000000b</span><br><span class="line">DESC_P    equ  1_000000000000000b</span><br><span class="line">DESC_DPL_0  equ   00_0000000000000b</span><br><span class="line">DESC_DPL_1  equ   01_0000000000000b</span><br><span class="line">DESC_DPL_2  equ   10_0000000000000b</span><br><span class="line">DESC_DPL_3  equ   11_0000000000000b</span><br><span class="line">DESC_S_CODE equ     1_000000000000b</span><br><span class="line">DESC_S_DATA equ  DESC_S_CODE</span><br><span class="line">DESC_S_sys  equ     0_000000000000b</span><br><span class="line">DESC_TYPE_CODE  equ      1000_00000000b;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  </span><br><span class="line">DESC_TYPE_DATA  equ      0010_00000000b;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00</span><br><span class="line">DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line">DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b</span><br><span class="line"></span><br><span class="line">;--------------   选择子属性  ---------------</span><br><span class="line">RPL0  equ   00b</span><br><span class="line">RPL1  equ   01b</span><br><span class="line">RPL2  equ   10b</span><br><span class="line">RPL3  equ   11b</span><br><span class="line">TI_GDT equ   000b</span><br><span class="line">TI_LDT equ   100b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;----------------   页表相关属性    --------------</span><br><span class="line">PG_P  equ   1b</span><br><span class="line">PG_RW_R equ  00b </span><br><span class="line">PG_RW_W equ  10b </span><br><span class="line">PG_US_S equ  000b </span><br><span class="line">PG_US_U equ  100b </span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include/ -o mbr.bin mbr.S </span><br><span class="line">nasm -I include/ -o loader.bin loader.S</span><br><span class="line"></span><br><span class="line">dd if=boot/mbr.bin of=../a.img bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=boot/loader.bin of=../a.img bs=512 count=4 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure><h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="https://s2.loli.net/2022/11/14/ZbInWVAMXChpkz1.png" alt="image.png"></p><h4 id="关于地址映射"><a href="#关于地址映射" class="headerlink" title="关于地址映射"></a>关于地址映射</h4><p>根据bochs中的调试指令<code> info tab</code>可以查看虚拟地址映射的物理地址，图中左边是虚拟地址，右边是物理地址</p><p><img src="https://s2.loli.net/2022/11/14/DP2F9gpXzBmdxle.png" alt="image.png"></p><p>第一条映射关系相当明显，映射了第0个页目录项的物理地址</p><p>第二条映射关系是第768个页表完成的映射关系，它所映射的也是第0个页目录项的物理地址，所以和第一条映射的物理地址相同</p><p>第三条映射关系中0xffc00000，负责表示页表项索引的高十位全部为1，而表示页表的索引中间10位全部为0，所以他指向的是最后一个页表（即第1023个页表）的第0项，而最后一个页表项中存放的是第0个页表的物理地址，所以指向了第0个页表，其值是 0x101000，此值被认为是最终的物理页地址。剩下的12就是偏移量，加上去就能得到0x00101fff，即最终的映射的物理地址是0x00101000~0x00101fff</p><p>第四条映射关系0xfff00000 的高 10 位依然为 0x3ff，中间 10 位是 1100000000b=0x300，这是第 768 个页目录项，该页目录项指向的页表与第 0 个页目录项指向的页表相同。所以虚拟地址 0xfff00000 映射为物理地址0x00101000 成立，即最终的映射的物理地址是0x00101000~0x00101fff</p><p>第五条映射关系0xfffff000高 10 位为 0x3ff，中间10位是0x3ff，映射的是第1023页的1023项，由于1023页目录项指向了该页目录的首地址，而页目录的首地址映射的是自己的物理地址，所以这里的前20位映射相当于是将页目录看作是一个页表进行映射，所以最低物理地址就是页目录的物理地址0x00100000，最大物理地址0x00100000+2<sup>12</sup>-1=0x00100fff。由此可以得出结论：如果虚拟地址的高 20 位为 0xfffff，经过我们的页目录表映射，将会访问到页目录表自己的物理地址。</p><h5 id="用虚拟地址获取页表中各数据类型的方法总结"><a href="#用虚拟地址获取页表中各数据类型的方法总结" class="headerlink" title="用虚拟地址获取页表中各数据类型的方法总结"></a>用虚拟地址获取页表中各数据类型的方法总结</h5><ul><li>获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也是页目录表中第 0 个页目录项自身的物理地址</li><li>访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录项的索引乘以 4 的积</li><li>访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff（第768个页目录项，指向的是页目录的物理地址），目的是获取页目录表物理地址。中间 10 位为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页表项，它必须是已经乘以 4 后的值</li></ul><h4 id="快表-TLB（Translation-Lookaside-Buffer）"><a href="#快表-TLB（Translation-Lookaside-Buffer）" class="headerlink" title="快表 TLB（Translation Lookaside Buffer）"></a>快表 TLB（Translation Lookaside Buffer）</h4><p>虽然分表机制解决了内存碎片等一系列问题，但是需要寄存器和内存花费更多的时间去寻址，为了解决这个问题，还是采用了缓存思想 ，添加了一个高速缓存专门用于虚拟地址页框和存储页框物理地址</p><p>高速缓存由于成本等原因，容量一般都很小，TLB 也是，因此 TLB 中的数据只是当前任务的部分页表，而且只有 P 位为 1 的页表项才有资格在 TLB 中，如果 TLB 被装满了，需要将很少使用的条目换出。TLB 里面存储的是程序运行所依赖的指令和数据的内存地址，任意时刻都必须保证地址的有效性，否则程序必然出错，所以 TLB 必须实时更新</p><p>TLB 中的条目是虚拟地址的高 20 位到物理地址高 20 位的映射结果，实际上就是从虚拟页框到物理页框的映射。除此之外 TLB中还有一些属性位，比如页表项的 RW 属性</p><p><img src="https://s2.loli.net/2022/11/14/kan7CTbEh6OU8oY.png" alt="image.png"></p><p>TLB 对开发人员不可见，但是开发人员依旧可以使用间接方法来改变TLB</p><ul><li>重新加载CR3（感觉像清空流水线）</li><li>使用<code>invlpg</code>指令，如<code>invlpg [0x1234]</code>因为其中的<code>0x1234</code>并非立即数数，所以得采用<code>[]</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护模式进阶&quot;&gt;&lt;a href=&quot;#保护模式进阶&quot; class=&quot;headerlink&quot; title=&quot;保护模式进阶&quot;&gt;&lt;/a&gt;保护模式进阶&lt;/h2&gt;&lt;h3 id=&quot;获取内存&quot;&gt;&lt;a href=&quot;#获取内存&quot; class=&quot;headerlink&quot; title=&quot;获</summary>
      
    
    
    
    
    <category term="操作系统真相还原" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>保护模式入门</title>
    <link href="http://example.com/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/10/29/%E5%88%9D%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-10-29T09:07:41.000Z</published>
    <updated>2022-11-14T08:01:23.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p><strong>在16位cpu天下时，并没有实模式的概念，但是随着cpu发展到了32位，寄存器，总线等许多硬件设备得到了更新换代，随之而来的就是cpu新的运行模式，但新出的cpu必须兼容以前老版本的16位的运行模式，所以才有了保护模式和实模式之分。</strong></p><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>到了保护模式下，内存段（如数据段、代码段等）不再是简单地用段寄存器加载一下段基址就能用，信息增加了很多，需要提前把段定义好才能使用。全局描述符表（Global Descriptor Table，GDT）是保护模式下内存段的登记表，寄存器GDTR负责指向它。</p><p>顾名思义，GDT是一个表，表中必然有表项，每一个表项大小为8个字，称作段描述符，用来描述各个内存段的起始地址、大小、权限等信息，可谓是相当详细。与之对应的，段寄存器也发生了变化，里面保存的不再是段地址，而是‘选择子’，selector，选择子用于索引GDT中的段描述符，看起来就像个数组下标一样。也正是因为段寄存器不再指向物理上的段地址，所以段寄存器中的地址没必要再左移四位硬凑20位的地址，一个32位的寄存器寻址范围是0x00000000 ~ 0xFFFFFFFF，即0~4GB，这样高效的寻址模式，称为平坦模式。</p><p>注意在GDT中第0（1）个描述符是不可用的，原因是在GDT中的段是要用选择子索引的，如果索引的选择子未初始化，选择子就是0，这将会导致直接指向第0个描述符。</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>在保护模式模式下，段描述符是放在内存之中，占8个字大小，一共64位，每一位都有其特殊意义</p><p><img src="https://s2.loli.net/2022/10/31/TZb6IMvn5rfitgC.png" alt="image.png"></p><ul><li><p>段基址：用于指向访问内存的起始地址</p></li><li><p>G：用于表示段界限的粒度大小，0表示粒度大小为1KB，1表示粒度大小为4GB</p></li><li><p>段界限：限制程序访问的范围，但这里的段界限只是一个单位，真正的段界限=G（粒度）*（段界限+1）-1。段界限存在两种拓展方向，向高地址拓展或向低地址拓展。</p></li><li><p>S：用来指定描述符的类型，0表示系统段，1表示非系统段，非系统段同样分为两种：代码段和数据段</p></li><li><p>TYPE：TYPE一共有四位，用于指定这段非系统段的相关权限</p><ul><li><p>X：EXecutable，表示该段是否可执行，数据和指令都是以同等地位存储在内存之中，但是指令可以执行但数据不能执行，所以可以用于区分代码段和数据段。代码段是可执行的，即 X 为 1。而数据段是不可执行的，即 X 为 0</p></li><li><p>R：Read，表示可读，R 为 1 表示可读，R 为 0 表示不可读</p></li><li><p>W：Write，表示可写，R 为 1 表示可写，R 为 0 表示不可写</p></li><li><p>C：Conforming，表示是否一致，一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段</p></li><li><p>A：Accessed，表示是否执行，由 CPU 设置，每当该段被 CPU 访问过后，CPU 就将此位置 1。</p></li><li><p>E：Extend，E 为 0 表示向上扩展，即地址越来越高，通q常用于代码段和数据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。</p><p><img src="https://s2.loli.net/2022/10/31/xTG23XNEmSF1Ljg.png" alt="image.png"></p></li></ul></li><li><p>DPL：表示描述符特权级，这两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大。特权级是保护模式下才有的东西，CPU 由实模式进入保护模式后，特权级自动为 0，用户程序通常处于 3 特权级，权限最小。某些指令只能在 0 特权级下执行，从而保证了安全。</p></li><li><p>P：表示段是否存在，如果段存在于内存中，P 为 1，否则 P 为 0。P 字段是由 CPU 来检查的，如果为 0，CPU 将抛出异常，转到相应的异常处理程序。当初 CPU 的设计是当内存不足时，可以将段描述符中对应的内存段换出，也就是可以把不常用的段直接换出到硬盘，待使用时再加载进来。</p></li><li><p>AVL：操作系统可以随意用此位</p></li><li><p>L：用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段</p></li><li><p>D/B：有效表示地址（段内偏移地址）及操作数的大小。对于代码段来说，此位是 D 位，若 D 为 0，表示指令中的有效地址和操作数是 16 位，指令有效地址用 IP 寄存器。若 D 为 1，表示指令中的有效地址及操作数是 32 位，指令有效地址用 EIP 寄存器。对于栈段来说，此位是 B 位，用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地址上限。若 B 为 0，使用的是 sp 寄存器，也就是栈的起始地址是 16 位寄存器的最大寻址范围，0xFFFF。若 B 为 1，使用的是 esp 寄存器，也就是栈的起始地址是 32 位寄存器的最大寻址范围，0xFFFFFFFF。</p></li></ul><h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h3><p>GDT位于内存之中，寄存器GDTR(GDT Reigster)负责指向它，GDTR是个48位的寄存器，对于该寄存器的初始化由专门的指令lgdt来做。</p><p><img src="https://s2.loli.net/2022/11/02/S4jJwYup8GvZNfX.png" alt="_ZM3M2T2GXI7KCM_4GA__F6.png"></p><h3 id="选择子-selector"><a href="#选择子-selector" class="headerlink" title="选择子(selector)"></a>选择子(selector)</h3><p>段寄存器 CS、DS、ES、FS、GS、SS在实模式下时只能用于存储段基地址，而在进入保护模式之后，这一限制就取消了，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西—selector.段寄存器是 16 位，所以选择子也是 16 位。</p><p><img src="https://s2.loli.net/2022/11/02/HM9uXwyLsYdGpED.png" alt="image.png"></p><ul><li>RPL：请求特权级，即请求特权级，可以表示 0、1、2、3 四种特权级</li><li>TI：0表示在GDT中索引描述符，1表示在LDT中索引描述符</li><li>描述符索引值：指向GDT或LDT之间的索引符地址</li></ul><h4 id="加载选择子的保护"><a href="#加载选择子的保护" class="headerlink" title="加载选择子的保护"></a>加载选择子的保护</h4><p>当引用一个内存段时，实际上就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，在这时候，CPU会在以下几方面做出检查。</p><ul><li>根据选择子的值验证段描述符是否越界<ul><li>描述符表基地址+选择子中的索引值*8+7 &lt;=描述符表基地址+描述符表界限值。</li></ul></li><li>利用type位检查段的类型<ul><li>只有具备可执行属性的段（代码段）才能加载到 CS 段寄存器中。</li><li>只具备执行属性的段（代码段）不允许加载到除 CS 外的段寄存器中。</li><li>只有具备可写属性的段（数据段）才能加载到 SS 栈段寄存器中。</li><li>至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中<img src="https://s2.loli.net/2022/11/03/5A3nhFDGHvjmOsP.png" alt="image.png"></li></ul></li><li>利用P位检查段是否存在<ul><li>CPU 通过段描述符中的 P 位来确认内存段是否存在，如果P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0，则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。</li></ul></li></ul><h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><p>GDT是全局描述符表，与之相对的自然有局部描述符表。CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是 LDT，即每个任务都有自己的 LDT，随着任务切换，也要切换相应任务的 LDT。LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR，即 LDT Register。同样也有专门的指令用于加载 LDT，即 lldt。以后每切换任务时，都要用 lldt 指令重新加载任务的私有内存段。</p><h3 id="进入选择模式"><a href="#进入选择模式" class="headerlink" title="进入选择模式"></a>进入选择模式</h3><p>进入选择模式一共分为三步：第一步打开A20 ，第二步加载GDT ，第三步将CR0的PE置1</p><h4 id="打开A20"><a href="#打开A20" class="headerlink" title="打开A20"></a>打开A20</h4><p>CPU为了兼容地址回绕的问题，用A20Gate（第21根地址线）来控制是否开启地址回绕，所以在进入保护模式之前，要把A20给关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al，0x92 </span><br><span class="line">or al，0000_0010B </span><br><span class="line">out 0x92，al</span><br></pre></td></tr></table></figure><h5 id="地址回绕（wrap-around）"><a href="#地址回绕（wrap-around）" class="headerlink" title="地址回绕（wrap-around）"></a>地址回绕（wrap-around）</h5><p>实模式下由于采用的是“段地址：偏移地址”的方法，实模式下的寄存器都是16位，所以理论存在的最大地址为0xFFFF * 16 + 0xFFFF = 0x1FFEF。而实模式下的可用的地址线有20跟，最大寻址空间是0xFFFFF（1MB），从比较中可得知，寄存器的最大地址比寻址空间稍微大那么一点，但是这些多余的地址并没有指向真正物理地址。为了让这些多余的地址也能够利用起来，CPU采用的做法是将超过 1MB 的部分自动回绕到 0 地址，继续从 0地址开始映射。相当于把地址对 1MB 求模。超过 1MB 多余出来的内存被称为高端内存区 HMA。</p><h4 id="CR0-寄存器的-PE-位"><a href="#CR0-寄存器的-PE-位" class="headerlink" title="CR0 寄存器的 PE 位"></a>CR0 寄存器的 PE 位</h4><p>控制寄存器CRX是CPU的窗口，既可以展示CPU的运行状态，又可用于控制CPU的内部状态，这里使用的是寄存器的PE（protect enable）的第0位，这里置0即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0 </span><br><span class="line">or eax, 0x00000001 </span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/nXBgdbT75WFhKL6.png" alt="image.png"></p><p>这里暂时只用到PE位</p><p><img src="https://s2.loli.net/2022/11/02/jeLoaEKbw8HV6SJ.png" alt="image.png"></p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><h4 id="boot-inc"><a href="#boot-inc" class="headerlink" title="boot.inc"></a>boot.inc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">;---------------loader and kernel---------------</span><br><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line"></span><br><span class="line">;---------------GDT 描述符属性------------------</span><br><span class="line">DESC_G_4K       equ     1_00000000000000000000000b      ;颗粒度：4K</span><br><span class="line">DESC_D_32       equ     1_0000000000000000000000b       ;操作数和地址大小：32位</span><br><span class="line">DESC_L          equ     0_000000000000000000000b        ;是否是64位代码段：否</span><br><span class="line">DESC_AVL        equ     0_00000000000000000000b         ;不用此位，暂设置为：0</span><br><span class="line">DESC_LIMIT_CODE2 equ    1111_0000000000000000b          ;段界限19-16位</span><br><span class="line">DESC_LIMIT_DATA2 equ    DESC_LIMIT_CODE2                ;段界限19-16位</span><br><span class="line">DESC_LIMIT_VIDEO2 equ   0000_000000000000000b           ;显存</span><br><span class="line">DESC_P          equ     1_000000000000000b              ;表示段存在</span><br><span class="line">DESC_DPL_0      equ     00_0000000000000b               ;特权级：0</span><br><span class="line">DESC_DPL_1      equ     01_0000000000000b               ;特权级：1</span><br><span class="line">DESC_DPL_2      equ     10_0000000000000b               ;特权级：2</span><br><span class="line">DESC_DPL_3      equ     11_0000000000000b               ;特权级：3</span><br><span class="line">DESC_S_CODE     equ     1_000000000000b                 ;表示非系统段</span><br><span class="line">DESC_S_DATA     equ     DESC_S_CODE                     ;数据段，属于非系统段一部分</span><br><span class="line">DESC_S_SYS      equ     0_000000000000b                 ;表示系统段</span><br><span class="line">DESC_TYPE_CODE  equ     1000_00000000b                  ;Type字段-代码段：x=1,c=0,r=0,a=0</span><br><span class="line">DESC_TYPE_DATA  equ     0010_00000000b                  ;Type字段-数据段：x=0,e=0,w=1,a=0</span><br><span class="line"></span><br><span class="line">DESC_CODE_HIGH4 equ     (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00</span><br><span class="line">DESC_DATA_HIGH4 equ     (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line">DESC_VIDEO2_HIGH4 equ   (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B</span><br><span class="line"></span><br><span class="line">;--------------选择子 属性-------------------</span><br><span class="line">RPL0    equ     00b</span><br><span class="line">RPL1    equ     01b</span><br><span class="line">RPL2    equ     10b</span><br><span class="line">RPL3    equ     11b</span><br><span class="line">TI_GDT  equ     000b</span><br><span class="line">TI_LDT  equ     100b</span><br></pre></td></tr></table></figure><p>注意书中的boot.inc是有错误的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_VIDEO2_HIGH4 equ   (0x00&lt;&lt;24) + DESC_G_4G + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br></pre></td></tr></table></figure><p>显存的起始地址是0xb8000，在段描述符低4字节中段基址0-15位存储的是0x8000，所以段描述符高4字节最初8位是段基址的23-16位的值应该是0xB，而不是0x00，所以这一行应该改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_VIDEO2_HIGH4 equ   (0x00&lt;&lt;24) + DESC_G_4G + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B</span><br></pre></td></tr></table></figure><h4 id="loader-S"><a href="#loader-S" class="headerlink" title="loader.S"></a>loader.S</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION LOADER vstart=LOADER_BASE_ADDR</span><br><span class="line">LOADER_STACK_TOP        equ     LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">jmp     loader_start</span><br><span class="line"></span><br><span class="line">;构建 GDT 及其内部的描述符</span><br><span class="line">GDT_BASE:</span><br><span class="line">        dd      0x00000000</span><br><span class="line">        dd      0x00000000</span><br><span class="line"></span><br><span class="line">CODE_DESC:</span><br><span class="line">        dd      0x0000FFFF</span><br><span class="line">        dd      DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">DATA_STACK_DESC:        ;直接用普通的数据段作为栈段</span><br><span class="line">        dd      0x0000FFFF</span><br><span class="line">        dd      DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">VIDEO_DESC:</span><br><span class="line">        dd      0x80000007      ;limit=(0xbffff - 0xb8000)/4k = 7</span><br><span class="line">        dd      DESC_VIDEO2_HIGH4;此时dpl为0</span><br><span class="line"></span><br><span class="line">GDT_SIZE        equ     $ - GDT_BASE    ;获取 GDT 大小</span><br><span class="line">GDT_LIMIT       equ     GDT_SIZE - 1    ;获取 段界限</span><br><span class="line"></span><br><span class="line">times   60      dq      0       ;预留60个空位，为以后填入中断描述符表和任务状态段TSS描述符留空间</span><br><span class="line">                                ;times 60 表示后面的内容循环60次，是nasm提供的伪指令</span><br><span class="line"></span><br><span class="line">SELECTOR_CODE   equ     (0x0001 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line">SELECTOR_DATA   equ     (0x0002 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line">SELECTOR_VIDEO  equ     (0x0003 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">;以下是 gdt 指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">gdt_ptr dw      GDT_LIMIT</span><br><span class="line">        dd      GDT_BASE</span><br><span class="line"></span><br><span class="line">loadermsg db &#x27;2 loader in real.&#x27;</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">;INT 0x10       功能号:0x13     功能描述符:打印字符串</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">;输入:</span><br><span class="line">;AH 子功能号=13H</span><br><span class="line">;BH = 页码</span><br><span class="line">;BL = 属性（若AL=00H或01H）</span><br><span class="line">;CX = 字符串长度</span><br><span class="line">;(DH,DL)=坐标(行，列)</span><br><span class="line">;ES:BP=字符串地址</span><br><span class="line">;AL=显示输出方式</span><br><span class="line">;0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</span><br><span class="line">;1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</span><br><span class="line">;2——字符串中只含显示字符和显示属性。显示后，光标位置不变。</span><br><span class="line">;3——字符串中只含显示字符和显示属性。显示后，光标位置改变。</span><br><span class="line">;无返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loader_start:</span><br><span class="line">        ;显示字符串，表示当前在实模式</span><br><span class="line">        mov sp, LOADER_BASE_ADDR</span><br><span class="line">        mov bp, loadermsg       ;ES:BP 字符串地址</span><br><span class="line">        mov cx, 17              ;字符串长度</span><br><span class="line">        mov ax, 0x1301          ;AH=13h，AL=01h</span><br><span class="line">        mov bx, 0x001f          ;页号为0（BH=0h），蓝底粉红字（BL=1fh）</span><br><span class="line">        mov dx, 0x1800          ;</span><br><span class="line">        int 0x10                ;int 10 BIOS中断</span><br><span class="line"></span><br><span class="line">        ;准备进入保护模式</span><br><span class="line">        ;1.打开A20地址线</span><br><span class="line">        in al, 0x92</span><br><span class="line">        or al, 00000010B</span><br><span class="line">        out 0x92, al</span><br><span class="line"></span><br><span class="line">        ;2.加载GDT</span><br><span class="line">        lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">        ;3.将CR0的PE位置1</span><br><span class="line">        mov eax, cr0</span><br><span class="line">        or eax, 0x00000001</span><br><span class="line">        mov cr0, eax</span><br><span class="line"></span><br><span class="line">        jmp dword SELECTOR_CODE:p_mode_start    ;刷新流水线</span><br><span class="line">                                               ;流水线是CPU 的工作方式，会把当前指令和后面的几个指令同时放在流水线中重叠执行，由于之前的代码是16位，接下来的代码变成32位了，指令按照16位进行译码会出错，通过刷新流水线可以解决这个问题</span><br><span class="line"></span><br><span class="line">[bits 32]       ;编译成32位程序</span><br><span class="line">p_mode_start:</span><br><span class="line">        mov ax, SELECTOR_DATA</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov esp, LOADER_STACK_TOP</span><br><span class="line">        mov ax, SELECTOR_VIDEO</span><br><span class="line">        mov gs, ax</span><br><span class="line">        mov byte [gs:160],&#x27;P&#x27;</span><br><span class="line"></span><br><span class="line">        jmp $</span><br></pre></td></tr></table></figure><h4 id="mbr-S"><a href="#mbr-S" class="headerlink" title="mbr.S"></a>mbr.S</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">; 清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0                   ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh   ; 右下角: (80,25),</span><br><span class="line">   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">   ; 下标从0开始，所以0x18=24,0x4f=79</span><br><span class="line">   int     10h                     ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出字符串:MBR</span><br><span class="line">   mov byte [gs:0x00],&#x27;1&#x27;</span><br><span class="line">   mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&#x27; &#x27;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&#x27;M&#x27;</span><br><span class="line">   mov byte [gs:0x05],0xA4   ;A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&#x27;B&#x27;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&#x27;R&#x27;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line"> </span><br><span class="line">   mov eax,LOADER_START_SECTOR ; 起始扇区lba地址</span><br><span class="line">   mov bx,LOADER_BASE_ADDR       ; 写入的地址</span><br><span class="line">   mov cx,4 ; 待读入的扇区数</span><br><span class="line">   call rd_disk_m_16 ; 以下读取程序的起始部分（一个扇区）</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR</span><br><span class="line">       </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">       ; eax=LBA扇区号</span><br><span class="line">       ; ebx=将数据写入的内存地址</span><br><span class="line">       ; ecx=读入的扇区数</span><br><span class="line">      mov esi,eax  ;备份eax</span><br><span class="line">      mov di,cx  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f   ;lba第24~27位</span><br><span class="line">      or al,0xe0   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">   ; 共需di*512/2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm -I include/ -o mbr.bin mbr.S </span><br><span class="line">nasm -I include/ -o loader.bin loader.S</span><br><span class="line"></span><br><span class="line">dd if=mbr.bin of=../a.img bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=loader.bin of=../a.img bs=512 count=4 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure><h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="https://s2.loli.net/2022/11/02/WbLdwtlr9umhpKi.png" alt="image.png"></p><h3 id="处理器微架构简介"><a href="#处理器微架构简介" class="headerlink" title="处理器微架构简介"></a>处理器微架构简介</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>CPU流水线技术是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令并行处理，以加速程序运行过程的技术。指令的每步有各自独立的电路来处理，每完成一步，就进到下一步，而前一步则处理后续指令。</p><p>CPU每执行一条指令都需要经过取指、译指、执行的过程。但在cpu中，每一步都有独立的电路结构去完成对应的能，就像流水线上的工人一样。这样的流水线结构大大增加了cpu的运行效率</p><p><img src="https://s2.loli.net/2022/11/02/1eraJXgsQ5yRbIY.png" alt="image.png"></p><p>值得一提的是，CPU 是按照程序中指令顺序来填充流水线的，也就是说按照程序计数器 PC（x86中是 cs：ip）中的值来装载流水线的，所以当执行到<code>jmp</code>指令时，cpu会自动清空原本的流水线</p><h4 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h4><p>乱序执行，指的是cpu并不按照原本代码中的顺序执行，而是按照一定的策略打乱代码之后执行，所打乱的代码之间不具备相关性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;一段栈代码</span><br><span class="line">mov eax , [0x1234] </span><br><span class="line">push eax </span><br><span class="line">call function</span><br></pre></td></tr></table></figure><p>第一步中要访问内存[0x1234]，而访存需要先寻址，在寻址过程之中可以先执行下面的代码<code>push eax</code></p><p>第二步将<code>push eax</code>可以拆分为<code>sub esp,4</code>、<code>mov [esp],eax</code>两部分</p><p>第三种将当前地址压入栈中，cs:ip跳转到对应的地址执行分支程序function</p><p>由于第 2 步中的微操作 <code>sub esp,4</code>，可以让 CPU 知道 esp 的最新值，不用等到 <code>mov [esp], eax</code> 完成，第 3 步 call 指令向栈中压入返回地址的操作就可以执行了。故第 2 步未执行完就开始第 3 步的执行了，也许第 3 步先于第 2 步完成。</p><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><p>cpu的指令在流水上运行时，时常会遇到分支指令（如if，else），这时cpu就需要判断将哪个分支放在流水线上，这个判断的过程叫做分支预测</p><p>分支预测最简单的算法是 2 位预测法。用 2 位 bit 的计数器来记录跳转状态，每跳转一次就加 1，直到加到最大值 3 就不再加啦，如果未跳转就减 1，直到减到最小值 0 就不再减了。当遇到跳转指令时，如果计数器的值大于 1 则跳转，如果小于等于 1 则不跳。这只是最简单的分支预测算法，CPU 中的预测法远比这个复杂，不过它们都是从 2 位预测法发展起来的。</p><p>Intel 的分支预测部件中用了分支目标缓冲器BTB（Branch Target Buffer），CPU 遇到分支指令时，先用分支指令的地址在 BTB 中查找，若找到相同地址的指令，根据跳转统计信息判断是否把相应的预测分支地址上的指令送上流水线。在真正执行时，根据实际分支流向，更新 BTB 中跳转统计信息。如果BTB中没有相同的记录，这时候可以使用 静态预测器（Static Predictor），存储在里面的预测策略是固定写死的，它是由人们经过大量统计之后，根据某些特征总结出来的。程序在实际执行转移分支指令后，再将转移记录录入到 BTB。</p><h3 id="jmp和流水线"><a href="#jmp和流水线" class="headerlink" title="jmp和流水线"></a>jmp和流水线</h3><p>在上面loader.s中有一段代码使用了远跳转，这里使用<code>jmp</code>有两个意图，一是加载正确的选择子，二是刷新流水线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SELECTOR_CODE:p_mode_start</span><br></pre></td></tr></table></figure><p>在实模式和保护模式中，段描述符缓冲寄存器都会保存段基地址，且在不重新引用一个段时，其中的存储的值是不会变的，所以从实模式进入保护模式时，原本20位的实模式段基址变成选择子就会出现错误，所以必须使用<code>jmp</code>来加载正确的选择子。</p><p>其次，在默认情况下，如果使用了未知的<code>[bits]</code>伪指令来配置运行环境，编译默认是按照16位实模式来编译。在loader.s中，完成的任务是由实模式进入保护模式，其中<code>[bits]</code>由16位变为32位，但由于cpu为了提高效率采用流水线，所以指令之间是重叠的，故原本应该是32位的程序仍然以16位来进行编译，这必然是错误的，为此必须清空已经装填好的流水线，即使用<code>jmp</code>指令来完成这一操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护模式&quot;&gt;&lt;a href=&quot;#保护模式&quot; class=&quot;headerlink&quot; title=&quot;保护模式&quot;&gt;&lt;/a&gt;保护模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在16位cpu天下时，并没有实模式的概念，但是随着cpu发展到了32位，寄存器，总线等许多硬件设备得到了更新</summary>
      
    
    
    
    
    <category term="操作系统真相还原" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
</feed>
